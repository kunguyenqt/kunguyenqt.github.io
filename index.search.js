var relearn_search_index = [
  {
    "content": "Loạt bài này được dịch từ cuốn sách “Dive into Design Patterns” của tác giả Alexander Shvets.\n",
    "description": "",
    "tags": null,
    "title": "Design Pattern",
    "uri": "/design-pattern/index.html"
  },
  {
    "content": "Design Pattern (Khuôn mẫu thiết kế) là giải pháp điển hình cho các vấn đề thường xảy ra trong thiết kế phần mềm. Chúng giống như các bản thiết kế được tạo sẵn mà chúng ta có thể tùy chỉnh để giải quyết vấn đề thiết kế định kỳ trong mã của mình.\nBạn không thể chỉ tìm một khuôn mẫu và sao chép nó vào chương trình của mình, theo cách bạn có thể làm với các hàm hoặc thư viện có sẵn. Mẫu không phải là một đoạn code cụ thể, mà là một khái niệm chung để giải quyết một vấn đề. Bạn có thể làm theo các chi tiết được mô tả trong khuôn mẫu và triển khai một giải pháp phù hợp với thực tế của chương trình của riêng bạn.\nCác khuôn mẫu thường bị nhầm lẫn với các thuật toán (algorithm), bởi vì cả hai khái niệm đều mô tả các giải pháp điển hình cho một số vấn đề đã biết. Mặc dù một thuật toán luôn xác định một tập hợp rõ ràng các hành động có thể đạt được một số mục tiêu, nhưng một khuôn mẫu là một mô tả cấp cao hơn về một giải pháp. Mã của cùng một khuôn mẫu được áp dụng cho hai chương trình khác nhau có thể khác nhau.\nMột thuật toán tương tự như một công thức nấu ăn: cả hai đều có các bước rõ ràng để đạt được mục tiêu. Mặt khác, một khuôn mẫu giống như một bản thiết kế hơn: bạn có thể thấy kết quả và các tính năng của nó là gì, nhưng thứ tự thực hiện chính xác là tùy thuộc vào bạn.\nKhuôn mẫu bao gồm những gì? Hầu hết các khuôn mẫu được mô tả rất rõ ràng để mọi người có thể tái tạo chúng trong nhiều ngữ cảnh. Dưới đây là các phần thường có trong khuôn mẫu:\nMục đích của khuôn mẫu mô tả ngắn gọn cả vấn đề và giải pháp.\nĐộng lực giải thích thêm về vấn đề và giải pháp mà khuôn mẫu có thể thực hiện được.\nCấu trúc của các lớp thể hiện từng phần của khuôn mẫu và cách chúng liên kết với nhau.\nVí dụ về mã bằng một trong những ngôn ngữ lập trình phổ biến giúp dễ dàng nắm bắt ý tưởng đằng sau khuôn mẫu.\nMột số danh mục khuôn mẫu liệt kê các chi tiết hữu ích khác, chẳng hạn như khả năng ứng dụng của mẫu, các bước triển khai và mối quan hệ với các khuôn mẫu khác.\nPhân loại khuôn mẫu Các Design pattern khác nhau bởi độ phức tạp, mức độ chi tiết và quy mô áp dụng cho toàn bộ hệ thống được thiết kế. Tương tự như việc xây dựng một con đường: bạn có thể làm cho giao lộ an toàn hơn bằng cách lắp đặt một số đèn giao thông hoặc xây dựng toàn bộ nút giao thông nhiều tầng với lối đi ngầm cho người đi bộ.\nCác khuôn mẫu cơ bản và cấp thấp nhất thường được gọi là idioms. Chúng thường chỉ áp dụng cho một ngôn ngữ lập trình duy nhất.\nCác khuôn mẫu phổ quát và cấp cao nhất là các architectural patterns (khuôn mẫu kiến ​​trúc). Các nhà phát triển có thể triển khai các khuôn mẫu này bằng hầu hết mọi ngôn ngữ. Không giống như các khuôn mẫu khác, chúng có thể được sử dụng để thiết kế kiến trúc của toàn bộ ứng dụng. Ngoài ra, tất cả các khuôn mẫu có thể được phân loại theo ý định hoặc mục đích của chúng. Bao gồm ba nhóm khuôn mẫu chính:\nCreational patterns (Các khuôn mẫu khởi tạo) cung cấp các cơ chế tạo đối tượng làm tăng tính linh hoạt và sử dụng lại mã hiện có.\nStructural patterns (Các khuôn mẫu cấu trúc) giải thích cách lắp ráp các đối tượng và lớp thành các cấu trúc lớn hơn, đồng thời giữ cho các cấu trúc đó linh hoạt và hiệu quả.\nBehavioral patterns (Các khuôn mẫu hành vi) đảm bảo giao tiếp hiệu quả và phân công trách nhiệm giữa các đối tượng.\n",
    "description": "",
    "tags": null,
    "title": "Design Pattern là gì?",
    "uri": "/design-pattern/introduction/what-is-a-design-pattern/index.html"
  },
  {
    "content": "Design Pattern là giải pháp điển hình cho các vấn đề thường xảy ra trong thiết kế phần mềm. Chúng giống như các bản thiết kế được tạo sẵn mà bạn có thể tùy chỉnh để giải quyết vấn đề thiết kế trong mã của mình.\n",
    "description": "",
    "tags": null,
    "title": "Giới thiệu Design Pattern",
    "uri": "/design-pattern/introduction/index.html"
  },
  {
    "content": "Đây là một câu hỏi hay, nhưng không chính xác lắm. Design patterns không phải là những khái niệm phức tạp, mơ hồ. Các khuôn mẫu là giải pháp điển hình cho các vấn đề phổ biến trong thiết kế hướng đối tượng. Khi một giải pháp được lặp đi lặp lại trong nhiều dự án khác nhau, cuối cùng ai đó sẽ đặt tên cho nó và mô tả chi tiết giải pháp đó. Về cơ bản, đó là cách một khuôn mẫu được phát hiện.\nKhái niệm về các khuôn mẫu được Christopher Alexander mô tả lần đầu tiên trong A Pattern Language: Towns, Buildings, Construction. Cuốn sách mô tả một “ngôn ngữ” để thiết kế môi trường đô thị. Các đơn vị của ngôn ngữ này là các khuôn mẫu. Họ có thể mô tả cửa sổ nên cao bao nhiêu, tòa nhà nên có bao nhiêu tầng, diện tích cây xanh trong khu phố lớn như thế nào, v.v.\nÝ tưởng trên được chọn bởi bốn tác giả: Erich Gamma, John Vlissides, Ralph Johnson và Richard Helm. Năm 1995, họ xuất bản Design Patterns: Elements of Reusable Object-Oriented Software, trong đó họ áp dụng khái niệm design pattern vào lập trình. Cuốn sách có 23 mô hình giải quyết các vấn đề khác nhau của thiết kế hướng đối tượng và nhanh chóng trở thành cuốn sách bán chạy nhất. Do cái tên dài dòng của nó, mọi người bắt đầu gọi nó là “cuốn sách của nhóm bốn người”, cuốn sách này nhanh chóng được rút ngắn thành “cuốn sách GOF”.\nKể từ đó, hàng chục khuôn mẫu hướng đối tượng khác đã được phát hiện. “Cách tiếp cận khuôn mẫu” đã trở nên rất phổ biến trong các lĩnh vực lập trình khác, do đó, rất nhiều khuôn mẫu khác hiện cũng tồn tại bên ngoài thiết kế hướng đối tượng.\n",
    "description": "",
    "tags": null,
    "title": "Ai đã phát minh ra các khuôn mẫu?",
    "uri": "/design-pattern/introduction/who-invented-patterns/index.html"
  },
  {
    "content": "Creational Design Patterns\n",
    "description": "",
    "tags": null,
    "title": "Creational Design Patterns",
    "uri": "/design-pattern/creational-design-patterns/index.html"
  },
  {
    "content": "Factory Method (Phương thức xuất xưởng) hay còn được biết đến với tên khác là hàm khởi tạo ảo (Virtual Constructor), là một mô hình thiết kế thuộc nhóm mô hình khởi tạo, nó cung cấp một interface cho việc tạo đối tượng trong một siêu lớp. Tuy nhiên nó cho phép các lớp con thay đổi kiểu của đối tượng sẽ được tạo.\nĐặt vấn đề Hãy tưởng tượng rằng bạn đang tạo một ứng dụng quản lý chuỗi cung ứng hàng hóa. Phiên bản đầu tiên của ứng dụng chỉ có thể xử lý việc vận chuyển thông qua xe tải, vì thế phần lớn code của bạn nằm trong lớp Truck.\nSau một thời gian, ứng dụng của bạn được sử dụng rộng rãi và mỗi ngày bạn nhận hàng tá các đơn từ các công ty vận chuyển trên đường biển mong muốn tích hợp vận tải biển vào ứng dụng của bạn.\nĐó là 1 tin tốt phải không? Tuy nhiên phần lớn code hiện tại của bạn được ghép nối trong lớp Truck, việc thêm lớp Ships vào ứng dụng sẽ làm chúng ta cần phải thay đổi phần code cơ sở. Hơn nữa, nếu sau này bạn muốn thêm vào một hình thức vận chuyển khác vào ứng dụng của bạn, bạn có lẽ sẽ phải thay đổi tất cả những thứ trên.\nKết quả là bạn sẽ có một đống mã nguồn phức tạp, rối rắm và khiến ứng dụng của bạn trở nên phụ thuộc vào các phương thức vận tải khác nhau.\nGiải pháp Mô hình Factory Method gợi ý cho bạn thay đổi trực tiếp việc khởi tạo đối tượng (thông qua toán tử new) bằng việc gọi đến một phương thức khởi tạo đặc biệt. Thực chất, các đối tượng vẫn được tạo thông qua toán tử new, tuy nhiên nó sẽ được gọi thông qua phương thức khởi tạo (Factory Method). Các đối tượng được trả về bởi phương thức khởi tạo này thường được gọi với tên là \" sản phẩm (products)\"\nKhi mới nhìn vào, sự thay đổi này trông có vẻ vô nghĩa bởi vì chúng ta chỉ chuyển việc gọi hàm tạo từ một phần của chương trình tới nơi khác. Tuy nhiên, chúng ta có thể thấy bây giờ bạn có thể viết lại (override) phương thức khởi tạo trong các lớp con và thay đổi lớp của các sản phẩm, những đối tượng mà được tạo bởi phương thức này.\nTuy nhiên, có một hạn chế nhỏ: các lớp con chỉ có thể trả về các loại sản phẩm khác nhau nếu những sản phẩm này có một lớp cơ sở hoặc interface chung. Ngoài ra, Factory Method trong lớp cơ sở phải có kiểu trả về được khai báo với interface này.\nVí dụ, cả hai lớp Truck và Ship nên triển khai giao diện vận chuyển, giao diện này khai báo một phương thức có tên là deliver. Mỗi lớp thực hiện phương pháp này khác nhau: xe tải giao hàng bằng đường bộ, tàu giao hàng bằng đường biển. Factory Method trong lớp RoadLogistics trả về các đối tượng xe tải, trong khi Factory Method trong lớp SeaLogistics trả về tàu.\nPhần code sử dụng Factory Method (thường được gọi là client code) sẽ không thấy được sự khác nhau giữa sản phẩm thực tế được trả về từ các lớp con khác nhau. Client coi tất cả các sản phẩm là abstract Trasport ( lớp vận chuyển trừu tượng).\nKhách hàng sẽ biết rằng tất cả các đối tượng vận chuyển đều phải có phương thức phân phối, nhưng cách thức hoạt động của nó không quan trọng đối với khách hàng.\nCấu trúc Product khai báo interface chung cho tất cả các đối tượng và có thể được tạo ra bởi Creator và các lớp con của nó.\nConcrete Products có nội dung khác với product interface.\nLớp Creator khai báo Factory Method dùng để trả về đối tượng product mới. Một điều quan trọng là kiểu trả về của phương thức này khớp với product interface. Bạn có thể khai báo Factory Method trừu tượng để bắt buộc các lớp con phải viết lại phiên bản riêng cho Factory Method.Thay vào đó, Factory Method cơ sở có thể trả về một số loại sản phẩm mặc định.\nLưu ý, mặc dù tên của nó như thế nhưng việc tạo sản phẩm không phải là trách nhiệm chính của Creator. Thông thường, lớp Creator đã có sẵn một số logic nghiệp vụ cốt lõi liên quan đến sản phẩm. Factory Method giúp tách logic này khỏi các lớp sản phẩm cụ thể. Đây là một phép loại suy: một công ty phát triển phần mềm lớn có thể có một bộ phận đào tạo lập trình viên. Tuy nhiên, chức năng chính của toàn bộ công ty vẫn là viết mã, không sản xuất lập trình viên.\nConcrete Creators ghi đè Factory Method cơ sở để nó trả về một loại sản phẩm khác.\nLưu ý rằng Factory Method không phải lúc nào cũng phải tạo phiên bản mới. Nó cũng có thể trả về các đối tượng hiện có từ cache, nhóm đối tượng hoặc từ một nguồn khác.\nPseudocode Ví dụ này sẽ minh họa cách Factory Method có thể được sử dụng để tạo các phần tử giao diện người dùng trên đa nền tảng mà không cần ghép mã máy khách với các lớp giao diện người dùng cụ thể.\nClass Dialog cơ sở sử dụng các phần tử giao diện người dùng khác nhau để hiển thị cửa sổ của nó. Trong các hệ điều hành khác nhau, các phần tử này có thể trông hơi khác một chút, nhưng chúng vẫn phải hoạt động nhất quán. Một nút trong Windows vẫn là một nút trong Linux.\nKhi Factory Method bắt đầu hoạt động, bạn không cần phải viết lại logic của Dialog cho từng hệ điều hành. Nếu chúng ta khai báo một Factory Method để tạo các nút bên trong lớp Dialog cơ sở, thì sau này chúng ta có thể tạo một lớp con Dialog trả về các nút kiểu Windows từ Factory Method. Sau đó, lớp con kế thừa hầu hết mã của Dialog từ lớp cơ sở, nhưng nhờ Factory Method, nó có thể hiển thị các nút tìm kiếm của Windows trên màn hình.\nĐể Pattern này hoạt động, lớp Dialog cơ sở phải hoạt động với các nút trừu tượng nghĩa là chúng ta sẽ viết một lớp cơ sở hoặc giao diện mà tất cả các nút cụ thể tuân theo. Bằng cách này, code của Dialog vẫn hoạt động, cho dù nó hoạt động với loại nút nào.\nTất nhiên, bạn cũng có thể áp dụng phương pháp này cho các thành phần giao diện người dùng khác. Tuy nhiên, với mỗi phương thức xuất xưởng mới mà bạn thêm vào Dialog, bạn sẽ tiến gần hơn đến mẫu Abstract Factory. Chúng ta sẽ nói về mô hình này sau.\n1 // The creator class declares the factory method that must\r2 // return an object of a product class. The creator's subclasses\r3 // usually provide the implementation of this method.\r4 class Dialog is\r5 // The creator may also provide some default implementation\r6 // of the factory method.\r7 abstract method createButton()\r8\r9 // Note that, despite its name, the creator's primary\r10 // responsibility isn't creating products. It usually\r78 Creational Design Patterns / Factory Method11 // contains some core business logic that relies on product\r12 // objects returned by the factory method. Subclasses can\r13 // indirectly change that business logic by overriding the\r14 // factory method and returning a different type of product\r15 // from it.\r16 method render() is\r17 // Call the factory method to create a product object.\r18 Button okButton = createButton()\r19 // Now use the product.\r20 okButton.onClick(closeDialog)\r21 okButton.render()\r22\r23\r24 // Concrete creators override the factory method to change the\r25 // resulting product's type.\r26 class WindowsDialog extends Dialog is\r27 method createButton() is\r28 return new WindowsButton()\r29\r30 class WebDialog extends Dialog is\r31 method createButton() is\r32 return new HTMLButton()\r33\r34\r35 // The product interface declares the operations that all\r36 // concrete products must implement.\r37 interface Button is\r38 method render()\r39 method onClick(f)\r40\r41 // Concrete products provide various implementations of the\r42 // product interface.\r79 Creational Design Patterns / Factory Method43 class WindowsButton implements Button is\r44 method render(a, b) is\r45 // Render a button in Windows style.\r46 method onClick(f) is\r47 // Bind a native OS click event.\r48\r49 class HTMLButton implements Button is\r50 method render(a, b) is\r51 // Return an HTML representation of a button.\r52 method onClick(f) is\r53 // Bind a web browser click event.\r54\r55\r56 class Application is\r57 field dialog: Dialog\r58\r59 // The application picks a creator's type depending on the\r60 // current configuration or environment settings.\r61 method initialize() is\r62 config = readApplicationConfigFile()\r63\r64 if (config.OS == \"Windows\") then\r65 dialog = new WindowsDialog()\r66 else if (config.OS == \"Web\") then\r67 dialog = new WebDialog()\r68 else\r69 throw new Exception(\"Error! Unknown operating system.\")\r70\r71 // The client code works with an instance of a concrete\r72 // creator, albeit through its base interface. As long as\r73 // the client keeps working with the creator via the base\r74 // interface, you can pass it any creator's subclass.\rỨng dụng Sử dụng Factory Method khi bạn không biết trước chính xác các loại và sự phụ thuộc của các đối tượng mà code của bạn sẽ hoạt động cùng.\nFactory Method tách phần code xây dựng sản phẩm khỏi phần sử dụng nó. Do đó, sẽ dễ dàng hơn khi cần mở rộng vì nó đã độc lập với toàn bộ phần code còn lại.\nVí dụ, để thêm mới một kiểu sản phẩm vào trong ứng dụng, bạn sẽ chỉ cần tạo 1 class con mới và override lại Factory method cho nó.\nSử dụng Factory Method khi bạn muốn cung cấp cho người dùng thư viện hoặc framework của bạn bằng cách mở rộng những thành phần bên trong của nó khi cần sử dụng. Kế thừa có lẽ là cách đơn giản nhất để mở rộng chức năng mặc định trong thư viện hoặc framework của bạn. Tuy nhiên làm cách nào để framework của bạn nhận biết được rằng các class con nên đc dùng thay vì các thành phần chung?\nGiải pháp ở đây là tối giản phần code xây dựng của các thành phần trong framework và đưa chúng vào một Factory Method, sau đó cho mọi người override lại method này để có thể tự mở rộng được các thành phần.\nHãy cùng xem chúng làm việc như thế nào: Tưởng tượng rằng bạn đang viết một ứng dụng sử dụng framework UI mã nguồn mở, ứng dụng của bạn sẽ có những nút hình tròn nhưng framework chỉ cung cấp các nút hình vuông. Bạn mở rộng lớp tiêu chuẩn Button bằng lớp con RoundButton. Tuy nhiên bây giờ bạn cần thông báo với lớp UIFramework để sử dụng class con thay vì sử dụng class mặc định.\nĐể khắc phục được vấn đề trên, bạn sẽ tạo một class con UIWithRoundButtons từ các class base trong Framework và viết lại phương thức createButton của nó. Trong khi phương thức này trả về đối tượng Button ở class cơ sở, bạn có thể làm cho class con của bạn trả về đối tượng RoundButton. Bây giờ sử dụng lớp UIWithRoundButtons thay vì UIFramework, đó chính là tất cả chúng ta cần!\nSử dụng Factory Method khi bạn muốn tiết kiệm tài nguyên hệ thống bằng cách sử dụng lại những đối tượng sẵn có thay vì xây dựng lại chúng mỗi lần sử dụng.\nBạn sẽ thường xuyên phải trải qua nhu cầu này khi xử lý các đối tượng lớn, sử dụng tài nguyên nhiều như là kết nối cơ sở dữ liệu, các tiệp tin hệ thống và tài nguyên mạng.\nHãy xem xét chúng ta có thể làm gì để tái sử dụng một đối tượng đã được tồn tại sẵn:\nĐầu tiên bạn cần tạo một vài kho lưu trữ để theo dõi tất cả các đối tượng đã được tạo. Khi ai đó yêu cầu tạo một đối tượng mới, chương trình sẽ tìm kiếm một đối tượng rảnh rỗi trong kho chứa của bạn và đưa nó cho phía client code. Nếu không có đối tượng nào rảnh rồi, chương trình sẽ tạo một đối tượng mới và đưa nó vào kho chứa. Điều này sẽ cần phải viết rất nhiều code, và chúng phải được đặt vào một nơi riêng biệt để tránh làm rối chương trình với những đoạn code trùng lặp.\nVà có lẽ nơi hiển nhiên và thuận tiện nhất để đặt chúng chính là phần hàm tạo của lớp mà có các đối tượng mà chúng ta đang cố gắng sử dụng lại. Tuy nhiên, một hàm tạo theo định nghĩa phải luôn trả về một đối tượng mới, nó không thể trả về một thực thể đã tồn tại. Chính vì thế bạn cần có một phương thức thông thường có khả năng tạo những đối tượng mới cũng như tái sử dụng lại những đối tượng đã tồn tại. Điều này rất giống với tư tưởng của Factory Method.\nCách thức triển khai Làm cho tất cả các sản phẩm tuân theo cùng interface. Interface này nên định nghĩa các phương thức hợp lý cho sản phẩm.\nThêm một Factory Method trống bên trong lớp khởi tạo. Kiểu trả về của phương thức này nên khớp với interface chung của sản phẩm.\nTrong phần code khởi tạo, tìm kiếm tất cả những tham chiếu tới hàm tạo của sản phẩm. Lần lượt thay thế chúng bằng cách gọi tới Factory Method, đồng thời trích xuất phần code tạo của sản phẩm vào Factory Method.\nBạn có thể sẽ cần thêm một tham số tạm thời vào Factory Method để kiểm soát kiểu trả về.\nTại phần này, phần code của Factory Method trông sẽ khá xấu, nó có thể có một toán tử switch lớn để chọn xem loại sản phẩm nào sẽ được tạo. Đừng lo về điều này vì chúng ta sẽ sửa nó sau.\nBây giờ, tạo một tập hợp các lớp con với phần tạo cho từng loại sản phẩm được liệt kê trong Factory Method. Ghi đè phần Factory Method trong các class con và trích dẫn một phần constructor code phù hợp từ phương thức cơ sở.\nNếu có nhiều loại sản phẩm và chúng không phù hợp để tạo các class con cho tất cả chúng, bạn có thể sử dụng lại tham số điều khiển từ lớp cơ sở trong các lớp con.\nVí dụ, tưởng tượng rằng bạn phải tuân theo mô hình các lớp phân cấp như sau: lớp cơ sở Mail với hai lớp con AirMail và GroundMail; các lớp Transport gồm Plane, Truck và Train. Trong khi lớp AirMail chỉ sử dụng đối tượng Plane, GroundMail lại làm việc nhiều với cả hai đối tượng Truck và Train. Bạn có thể tạo một class con mới (gọi là TrainMail) để xử lý cả 2 trường hợp, nhưng đó là sự lựa chọn khác. Phía code khách hàng có thể truyền một đối số vào Factory Method của lớp GroundMail để kiểm soát những loại sản phẩm nào nó muốn nhận.\nSau tất cả các chiết xuất, nếu Factory Method cơ sở trở nên trống, bạn có thể làm cho nó thành trừu tượng và nếu còn lại thứ gì đó trong phương thức này thì bạn có thể biến nó thành hành vi mặc định của phương thức.\nƯu và nhược điểm Ưu điểm:\nBạn tránh được sự liên kết chặt chẽ giữa phần tạo của đối tượng và các sản phẩm cụ thể.\nSingle Responsibility Principle : Bạn có thể chuyển phần code tạo ra sản phẩm vào một nơi nào đó trong trương trình để có thể dễ dàng hỗ trợ.\nOpen/Closed Principle : Bạn có thể đưa ra nhiều kiểu mới của sản phẩm vào chương trình mà không phá vỡ phần code đã tồn tại.\nNhược điểm:\nCode của bạn se trở nên phức tạo hơn khi bạn đưa ra nhiều lớp con để triển khai mẫu này. Trường hợp tốt nhất là khi bạn đang giới thiệu mẫu vào hệ thống phân cấp hiện có của các lớp tạo.\nMối quan hệ với những Khuôn mẫu khác Rất nhiều thiết kế bắt đầu bằng việc sử dụng Factory Method ( ít phức tạo và dễ dàng tùy chỉnh thông qua các lớp con) và phát triển theo hướng Abstract Factory, Prototype hoặc Builder (linh hoạt hơn, nhưng phức tạo hơn).\nCác lớp Abstract Factory thường xuyên dựa trên một tập hợp của các Factory Method, nhưng bạn cũng có thể dử dụng Prototype để soạn thảo các phương thức trên lớp này.\nBạn có thể sử dụng Factory Method cùng với Iterator để thu thập các lớp con và trả về các kiểu khác nhau của vòng lặp, cái mà tương thức với các đối tượng mà chúng ta cần thu gom.\nPrototype không dựa trên kế thừa, vì thế nó không có yếu điểm. Mặt khác, Prototype yêu cầu một khởi tạo phức tạp từ đối tượng nhân bản. Factory Method dựa trên kế thừa nhưng không yêu cầu các bước khởi tạo.\nFactory Method là một Template Method đặc biệt. Đồng thời, Factory Method có thể đóng vai trò là một bước trong Template Method lớn.\n",
    "description": "",
    "tags": null,
    "title": "Factory Method (Phương thức xuất xưởng)",
    "uri": "/design-pattern/structural-design-patterns/factory-method/index.html"
  },
  {
    "content": "Structural Design Patterns\n",
    "description": "",
    "tags": null,
    "title": "Structural Design Patterns",
    "uri": "/design-pattern/structural-design-patterns/index.html"
  },
  {
    "content": "Sự thật là bạn có thể làm việc với tư cách là một lập trình viên trong nhiều năm mà không biết về một khuôn mẫu nào. Rất nhiều người như thế. Tuy nhiên, ngay cả trong trường hợp đó, bạn có thể đã hoặc đang triển khai một số khuôn mẫu mà không hề hay biết. Vậy thì tại sao chúng ta nên lại dành thời gian tìm hiểu chúng?\nDesign patterns là một bộ công cụ gồm các giải pháp đã được thử và kiểm tra cho các vấn đề phổ biến trong thiết kế phần mềm. Ngay cả khi bạn chưa bao giờ gặp phải những vấn đề này, thì việc biết các mẫu vẫn hữu ích vì nó dạy bạn cách giải quyết tất cả các loại vấn đề bằng cách sử dụng các nguyên tắc của thiết kế hướng đối tượng.\nDesign patterns xác định một ngôn ngữ chung mà bạn và đồng đội của mình có thể sử dụng để giao tiếp hiệu quả hơn. Bạn có thể nói, “Ồ, chỉ cần sử dụng Singleton cho việc đó,” và mọi người sẽ hiểu ý tưởng đằng sau đề xuất của bạn. Không cần giải thích singleton là gì nếu bạn biết khuôn mẫu và tên của nó.\n",
    "description": "",
    "tags": null,
    "title": "Tại sao nên học Design Patterns?",
    "uri": "/design-pattern/introduction/why-should-i-learn-patterns/index.html"
  },
  {
    "content": "Behavioural Design Patterns\n",
    "description": "",
    "tags": null,
    "title": "Behavioural Design Patterns",
    "uri": "/design-pattern/behavioural-design-patterns/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "content": "Blog này nhằm chia sẻ các bài viết về công nghệ hoàn toàn bằng tiếng Việt. Với mong muốn nhiều người Việt Nam nhanh chóng tiếp cận với Công nghệ thông tin mà không gặp phải khó khăn về rào cản ngôn ngữ.\n",
    "description": "",
    "tags": null,
    "title": "NLKH BLOG",
    "uri": "/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tags",
    "uri": "/tags/index.html"
  }
]
