var relearn_search_index = [
  {
    "content": "Loạt bài này được dịch từ cuốn sách “Dive into Design Patterns” của tác giả Alexander Shvets.\n",
    "description": "",
    "tags": null,
    "title": "Design Pattern",
    "uri": "/design-pattern/index.html"
  },
  {
    "content": "Design Pattern (Khuôn mẫu thiết kế) là giải pháp điển hình cho các vấn đề thường xảy ra trong thiết kế phần mềm. Chúng giống như các bản thiết kế được tạo sẵn mà chúng ta có thể tùy chỉnh để giải quyết vấn đề thiết kế định kỳ trong mã của mình.\nBạn không thể chỉ tìm một khuôn mẫu và sao chép nó vào chương trình của mình, theo cách bạn có thể làm với các hàm hoặc thư viện có sẵn. Mẫu không phải là một đoạn code cụ thể, mà là một khái niệm chung để giải quyết một vấn đề. Bạn có thể làm theo các chi tiết được mô tả trong khuôn mẫu và triển khai một giải pháp phù hợp với thực tế của chương trình của riêng bạn.\nCác khuôn mẫu thường bị nhầm lẫn với các thuật toán (algorithm), bởi vì cả hai khái niệm đều mô tả các giải pháp điển hình cho một số vấn đề đã biết. Mặc dù một thuật toán luôn xác định một tập hợp rõ ràng các hành động có thể đạt được một số mục tiêu, nhưng một khuôn mẫu là một mô tả cấp cao hơn về một giải pháp. Mã của cùng một khuôn mẫu được áp dụng cho hai chương trình khác nhau có thể khác nhau.\nMột thuật toán tương tự như một công thức nấu ăn: cả hai đều có các bước rõ ràng để đạt được mục tiêu. Mặt khác, một khuôn mẫu giống như một bản thiết kế hơn: bạn có thể thấy kết quả và các tính năng của nó là gì, nhưng thứ tự thực hiện chính xác là tùy thuộc vào bạn.\nKhuôn mẫu bao gồm những gì? Hầu hết các khuôn mẫu được mô tả rất rõ ràng để mọi người có thể tái tạo chúng trong nhiều ngữ cảnh. Dưới đây là các phần thường có trong khuôn mẫu:\nMục đích của khuôn mẫu mô tả ngắn gọn cả vấn đề và giải pháp.\nĐộng lực giải thích thêm về vấn đề và giải pháp mà khuôn mẫu có thể thực hiện được.\nCấu trúc của các lớp thể hiện từng phần của khuôn mẫu và cách chúng liên kết với nhau.\nVí dụ về mã bằng một trong những ngôn ngữ lập trình phổ biến giúp dễ dàng nắm bắt ý tưởng đằng sau khuôn mẫu.\nMột số danh mục khuôn mẫu liệt kê các chi tiết hữu ích khác, chẳng hạn như khả năng ứng dụng của mẫu, các bước triển khai và mối quan hệ với các khuôn mẫu khác.\nPhân loại khuôn mẫu Các Design pattern khác nhau bởi độ phức tạp, mức độ chi tiết và quy mô áp dụng cho toàn bộ hệ thống được thiết kế. Tương tự như việc xây dựng một con đường: bạn có thể làm cho giao lộ an toàn hơn bằng cách lắp đặt một số đèn giao thông hoặc xây dựng toàn bộ nút giao thông nhiều tầng với lối đi ngầm cho người đi bộ.\nCác khuôn mẫu cơ bản và cấp thấp nhất thường được gọi là idioms. Chúng thường chỉ áp dụng cho một ngôn ngữ lập trình duy nhất.\nCác khuôn mẫu phổ quát và cấp cao nhất là các architectural patterns (khuôn mẫu kiến ​​trúc). Các nhà phát triển có thể triển khai các khuôn mẫu này bằng hầu hết mọi ngôn ngữ. Không giống như các khuôn mẫu khác, chúng có thể được sử dụng để thiết kế kiến trúc của toàn bộ ứng dụng. Ngoài ra, tất cả các khuôn mẫu có thể được phân loại theo ý định hoặc mục đích của chúng. Bao gồm ba nhóm khuôn mẫu chính:\nCreational patterns (Các khuôn mẫu khởi tạo) cung cấp các cơ chế tạo đối tượng làm tăng tính linh hoạt và sử dụng lại mã hiện có.\nStructural patterns (Các khuôn mẫu cấu trúc) giải thích cách lắp ráp các đối tượng và lớp thành các cấu trúc lớn hơn, đồng thời giữ cho các cấu trúc đó linh hoạt và hiệu quả.\nBehavioral patterns (Các khuôn mẫu hành vi) đảm bảo giao tiếp hiệu quả và phân công trách nhiệm giữa các đối tượng.\n",
    "description": "",
    "tags": null,
    "title": "Design Pattern là gì?",
    "uri": "/design-pattern/introduction/what-is-a-design-pattern/index.html"
  },
  {
    "content": "Design Pattern là giải pháp điển hình cho các vấn đề thường xảy ra trong thiết kế phần mềm. Chúng giống như các bản thiết kế được tạo sẵn mà bạn có thể tùy chỉnh để giải quyết vấn đề thiết kế trong mã của mình.\n",
    "description": "",
    "tags": null,
    "title": "Giới thiệu Design Pattern",
    "uri": "/design-pattern/introduction/index.html"
  },
  {
    "content": "Đây là một câu hỏi hay, nhưng không chính xác lắm. Design patterns không phải là những khái niệm phức tạp, mơ hồ. Các khuôn mẫu là giải pháp điển hình cho các vấn đề phổ biến trong thiết kế hướng đối tượng. Khi một giải pháp được lặp đi lặp lại trong nhiều dự án khác nhau, cuối cùng ai đó sẽ đặt tên cho nó và mô tả chi tiết giải pháp đó. Về cơ bản, đó là cách một khuôn mẫu được phát hiện.\nKhái niệm về các khuôn mẫu được Christopher Alexander mô tả lần đầu tiên trong A Pattern Language: Towns, Buildings, Construction. Cuốn sách mô tả một “ngôn ngữ” để thiết kế môi trường đô thị. Các đơn vị của ngôn ngữ này là các khuôn mẫu. Họ có thể mô tả cửa sổ nên cao bao nhiêu, tòa nhà nên có bao nhiêu tầng, diện tích cây xanh trong khu phố lớn như thế nào, v.v.\nÝ tưởng trên được chọn bởi bốn tác giả: Erich Gamma, John Vlissides, Ralph Johnson và Richard Helm. Năm 1995, họ xuất bản Design Patterns: Elements of Reusable Object-Oriented Software, trong đó họ áp dụng khái niệm design pattern vào lập trình. Cuốn sách có 23 mô hình giải quyết các vấn đề khác nhau của thiết kế hướng đối tượng và nhanh chóng trở thành cuốn sách bán chạy nhất. Do cái tên dài dòng của nó, mọi người bắt đầu gọi nó là “cuốn sách của nhóm bốn người”, cuốn sách này nhanh chóng được rút ngắn thành “cuốn sách GOF”.\nKể từ đó, hàng chục khuôn mẫu hướng đối tượng khác đã được phát hiện. “Cách tiếp cận khuôn mẫu” đã trở nên rất phổ biến trong các lĩnh vực lập trình khác, do đó, rất nhiều khuôn mẫu khác hiện cũng tồn tại bên ngoài thiết kế hướng đối tượng.\n",
    "description": "",
    "tags": null,
    "title": "Ai đã phát minh ra các khuôn mẫu?",
    "uri": "/design-pattern/introduction/who-invented-patterns/index.html"
  },
  {
    "content": "Creational Design Patterns\n",
    "description": "",
    "tags": null,
    "title": "Creational Design Patterns",
    "uri": "/design-pattern/creational-design-patterns/index.html"
  },
  {
    "content": "Factory Method (Phương thức xuất xưởng) hay còn được biết đến với tên khác là hàm khởi tạo ảo (Virtual Constructor), là một mô hình thiết kế thuộc nhóm mô hình khởi tạo, nó cung cấp một interface cho việc tạo đối tượng trong một siêu lớp. Tuy nhiên nó cho phép các lớp con thay đổi kiểu của đối tượng sẽ được tạo.\nĐặt vấn đề Hãy tưởng tượng rằng bạn đang tạo một ứng dụng quản lý chuỗi cung ứng hàng hóa. Phiên bản đầu tiên của ứng dụng chỉ có thể xử lý việc vận chuyển thông qua xe tải, vì thế phần lớn code của bạn nằm trong lớp Truck.\nSau một thời gian, ứng dụng của bạn được sử dụng rộng rãi và mỗi ngày bạn nhận hàng tá các đơn từ các công ty vận chuyển trên đường biển mong muốn tích hợp vận tải biển vào ứng dụng của bạn.\nĐó là 1 tin tốt phải không? Tuy nhiên phần lớn code hiện tại của bạn được ghép nối trong lớp Truck, việc thêm lớp Ships vào ứng dụng sẽ làm chúng ta cần phải thay đổi phần code cơ sở. Hơn nữa, nếu sau này bạn muốn thêm vào một hình thức vận chuyển khác vào ứng dụng của bạn, bạn có lẽ sẽ phải thay đổi tất cả những thứ trên.\nKết quả là bạn sẽ có một đống mã nguồn phức tạp, rối rắm và khiến ứng dụng của bạn trở nên phụ thuộc vào các phương thức vận tải khác nhau.\nGiải pháp Mô hình Factory Method gợi ý cho bạn thay đổi trực tiếp việc khởi tạo đối tượng (thông qua toán tử new) bằng việc gọi đến một phương thức khởi tạo đặc biệt. Thực chất, các đối tượng vẫn được tạo thông qua toán tử new, tuy nhiên nó sẽ được gọi thông qua phương thức khởi tạo (Factory Method). Các đối tượng được trả về bởi phương thức khởi tạo này thường được gọi với tên là \" sản phẩm (products)\"\nKhi mới nhìn vào, sự thay đổi này trông có vẻ vô nghĩa bởi vì chúng ta chỉ chuyển việc gọi hàm tạo từ một phần của chương trình tới nơi khác. Tuy nhiên, chúng ta có thể thấy bây giờ bạn có thể viết lại (override) phương thức khởi tạo trong các lớp con và thay đổi lớp của các sản phẩm, những đối tượng mà được tạo bởi phương thức này.\nTuy nhiên, có một hạn chế nhỏ: các lớp con chỉ có thể trả về các loại sản phẩm khác nhau nếu những sản phẩm này có một lớp cơ sở hoặc interface chung. Ngoài ra, Factory Method trong lớp cơ sở phải có kiểu trả về được khai báo với interface này.\nVí dụ, cả hai lớp Truck và Ship nên triển khai giao diện vận chuyển, giao diện này khai báo một phương thức có tên là deliver. Mỗi lớp thực hiện phương pháp này khác nhau: xe tải giao hàng bằng đường bộ, tàu giao hàng bằng đường biển. Factory Method trong lớp RoadLogistics trả về các đối tượng xe tải, trong khi Factory Method trong lớp SeaLogistics trả về tàu.\nPhần code sử dụng Factory Method (thường được gọi là client code) sẽ không thấy được sự khác nhau giữa sản phẩm thực tế được trả về từ các lớp con khác nhau. Client coi tất cả các sản phẩm là abstract Trasport ( lớp vận chuyển trừu tượng).\nKhách hàng sẽ biết rằng tất cả các đối tượng vận chuyển đều phải có phương thức phân phối, nhưng cách thức hoạt động của nó không quan trọng đối với khách hàng.\nCấu trúc Product khai báo interface chung cho tất cả các đối tượng và có thể được tạo ra bởi Creator và các lớp con của nó.\nConcrete Products có nội dung khác với product interface.\nLớp Creator khai báo Factory Method dùng để trả về đối tượng product mới. Một điều quan trọng là kiểu trả về của phương thức này khớp với product interface. Bạn có thể khai báo Factory Method trừu tượng để bắt buộc các lớp con phải viết lại phiên bản riêng cho Factory Method.Thay vào đó, Factory Method cơ sở có thể trả về một số loại sản phẩm mặc định.\nLưu ý, mặc dù tên của nó như thế nhưng việc tạo sản phẩm không phải là trách nhiệm chính của Creator. Thông thường, lớp Creator đã có sẵn một số logic nghiệp vụ cốt lõi liên quan đến sản phẩm. Factory Method giúp tách logic này khỏi các lớp sản phẩm cụ thể. Đây là một phép loại suy: một công ty phát triển phần mềm lớn có thể có một bộ phận đào tạo lập trình viên. Tuy nhiên, chức năng chính của toàn bộ công ty vẫn là viết mã, không sản xuất lập trình viên.\nConcrete Creators ghi đè Factory Method cơ sở để nó trả về một loại sản phẩm khác.\nLưu ý rằng Factory Method không phải lúc nào cũng phải tạo phiên bản mới. Nó cũng có thể trả về các đối tượng hiện có từ cache, nhóm đối tượng hoặc từ một nguồn khác.\nPseudocode Ví dụ này sẽ minh họa cách Factory Method có thể được sử dụng để tạo các phần tử giao diện người dùng trên đa nền tảng mà không cần ghép mã máy khách với các lớp giao diện người dùng cụ thể.\nClass Dialog cơ sở sử dụng các phần tử giao diện người dùng khác nhau để hiển thị cửa sổ của nó. Trong các hệ điều hành khác nhau, các phần tử này có thể trông hơi khác một chút, nhưng chúng vẫn phải hoạt động nhất quán. Một nút trong Windows vẫn là một nút trong Linux.\nKhi Factory Method bắt đầu hoạt động, bạn không cần phải viết lại logic của Dialog cho từng hệ điều hành. Nếu chúng ta khai báo một Factory Method để tạo các nút bên trong lớp Dialog cơ sở, thì sau này chúng ta có thể tạo một lớp con Dialog trả về các nút kiểu Windows từ Factory Method. Sau đó, lớp con kế thừa hầu hết mã của Dialog từ lớp cơ sở, nhưng nhờ Factory Method, nó có thể hiển thị các nút tìm kiếm của Windows trên màn hình.\nĐể Pattern này hoạt động, lớp Dialog cơ sở phải hoạt động với các nút trừu tượng nghĩa là chúng ta sẽ viết một lớp cơ sở hoặc giao diện mà tất cả các nút cụ thể tuân theo. Bằng cách này, code của Dialog vẫn hoạt động, cho dù nó hoạt động với loại nút nào.\nTất nhiên, bạn cũng có thể áp dụng phương pháp này cho các thành phần giao diện người dùng khác. Tuy nhiên, với mỗi phương thức xuất xưởng mới mà bạn thêm vào Dialog, bạn sẽ tiến gần hơn đến mẫu Abstract Factory. Chúng ta sẽ nói về mô hình này sau.\n1 // The creator class declares the factory method that must\r2 // return an object of a product class. The creator's subclasses\r3 // usually provide the implementation of this method.\r4 class Dialog is\r5 // The creator may also provide some default implementation\r6 // of the factory method.\r7 abstract method createButton()\r8\r9 // Note that, despite its name, the creator's primary\r10 // responsibility isn't creating products. It usually\r78 Creational Design Patterns / Factory Method11 // contains some core business logic that relies on product\r12 // objects returned by the factory method. Subclasses can\r13 // indirectly change that business logic by overriding the\r14 // factory method and returning a different type of product\r15 // from it.\r16 method render() is\r17 // Call the factory method to create a product object.\r18 Button okButton = createButton()\r19 // Now use the product.\r20 okButton.onClick(closeDialog)\r21 okButton.render()\r22\r23\r24 // Concrete creators override the factory method to change the\r25 // resulting product's type.\r26 class WindowsDialog extends Dialog is\r27 method createButton() is\r28 return new WindowsButton()\r29\r30 class WebDialog extends Dialog is\r31 method createButton() is\r32 return new HTMLButton()\r33\r34\r35 // The product interface declares the operations that all\r36 // concrete products must implement.\r37 interface Button is\r38 method render()\r39 method onClick(f)\r40\r41 // Concrete products provide various implementations of the\r42 // product interface.\r79 Creational Design Patterns / Factory Method43 class WindowsButton implements Button is\r44 method render(a, b) is\r45 // Render a button in Windows style.\r46 method onClick(f) is\r47 // Bind a native OS click event.\r48\r49 class HTMLButton implements Button is\r50 method render(a, b) is\r51 // Return an HTML representation of a button.\r52 method onClick(f) is\r53 // Bind a web browser click event.\r54\r55\r56 class Application is\r57 field dialog: Dialog\r58\r59 // The application picks a creator's type depending on the\r60 // current configuration or environment settings.\r61 method initialize() is\r62 config = readApplicationConfigFile()\r63\r64 if (config.OS == \"Windows\") then\r65 dialog = new WindowsDialog()\r66 else if (config.OS == \"Web\") then\r67 dialog = new WebDialog()\r68 else\r69 throw new Exception(\"Error! Unknown operating system.\")\r70\r71 // The client code works with an instance of a concrete\r72 // creator, albeit through its base interface. As long as\r73 // the client keeps working with the creator via the base\r74 // interface, you can pass it any creator's subclass.\rỨng dụng Sử dụng Factory Method khi bạn không biết trước chính xác các loại và sự phụ thuộc của các đối tượng mà code của bạn sẽ hoạt động cùng.\nFactory Method tách phần code xây dựng sản phẩm khỏi phần sử dụng nó. Do đó, sẽ dễ dàng hơn khi cần mở rộng vì nó đã độc lập với toàn bộ phần code còn lại.\nVí dụ, để thêm mới một kiểu sản phẩm vào trong ứng dụng, bạn sẽ chỉ cần tạo 1 class con mới và override lại Factory method cho nó.\nSử dụng Factory Method khi bạn muốn cung cấp cho người dùng thư viện hoặc framework của bạn bằng cách mở rộng những thành phần bên trong của nó khi cần sử dụng. Kế thừa có lẽ là cách đơn giản nhất để mở rộng chức năng mặc định trong thư viện hoặc framework của bạn. Tuy nhiên làm cách nào để framework của bạn nhận biết được rằng các class con nên đc dùng thay vì các thành phần chung?\nGiải pháp ở đây là tối giản phần code xây dựng của các thành phần trong framework và đưa chúng vào một Factory Method, sau đó cho mọi người override lại method này để có thể tự mở rộng được các thành phần.\nHãy cùng xem chúng làm việc như thế nào: Tưởng tượng rằng bạn đang viết một ứng dụng sử dụng framework UI mã nguồn mở, ứng dụng của bạn sẽ có những nút hình tròn nhưng framework chỉ cung cấp các nút hình vuông. Bạn mở rộng lớp tiêu chuẩn Button bằng lớp con RoundButton. Tuy nhiên bây giờ bạn cần thông báo với lớp UIFramework để sử dụng class con thay vì sử dụng class mặc định.\nĐể khắc phục được vấn đề trên, bạn sẽ tạo một class con UIWithRoundButtons từ các class base trong Framework và viết lại phương thức createButton của nó. Trong khi phương thức này trả về đối tượng Button ở class cơ sở, bạn có thể làm cho class con của bạn trả về đối tượng RoundButton. Bây giờ sử dụng lớp UIWithRoundButtons thay vì UIFramework, đó chính là tất cả chúng ta cần!\nSử dụng Factory Method khi bạn muốn tiết kiệm tài nguyên hệ thống bằng cách sử dụng lại những đối tượng sẵn có thay vì xây dựng lại chúng mỗi lần sử dụng.\nBạn sẽ thường xuyên phải trải qua nhu cầu này khi xử lý các đối tượng lớn, sử dụng tài nguyên nhiều như là kết nối cơ sở dữ liệu, các tiệp tin hệ thống và tài nguyên mạng.\nHãy xem xét chúng ta có thể làm gì để tái sử dụng một đối tượng đã được tồn tại sẵn:\nĐầu tiên bạn cần tạo một vài kho lưu trữ để theo dõi tất cả các đối tượng đã được tạo. Khi ai đó yêu cầu tạo một đối tượng mới, chương trình sẽ tìm kiếm một đối tượng rảnh rỗi trong kho chứa của bạn và đưa nó cho phía client code. Nếu không có đối tượng nào rảnh rồi, chương trình sẽ tạo một đối tượng mới và đưa nó vào kho chứa. Điều này sẽ cần phải viết rất nhiều code, và chúng phải được đặt vào một nơi riêng biệt để tránh làm rối chương trình với những đoạn code trùng lặp.\nVà có lẽ nơi hiển nhiên và thuận tiện nhất để đặt chúng chính là phần hàm tạo của lớp mà có các đối tượng mà chúng ta đang cố gắng sử dụng lại. Tuy nhiên, một hàm tạo theo định nghĩa phải luôn trả về một đối tượng mới, nó không thể trả về một thực thể đã tồn tại. Chính vì thế bạn cần có một phương thức thông thường có khả năng tạo những đối tượng mới cũng như tái sử dụng lại những đối tượng đã tồn tại. Điều này rất giống với tư tưởng của Factory Method.\nCách thức triển khai Làm cho tất cả các sản phẩm tuân theo cùng interface. Interface này nên định nghĩa các phương thức hợp lý cho sản phẩm.\nThêm một Factory Method trống bên trong lớp khởi tạo. Kiểu trả về của phương thức này nên khớp với interface chung của sản phẩm.\nTrong phần code khởi tạo, tìm kiếm tất cả những tham chiếu tới hàm tạo của sản phẩm. Lần lượt thay thế chúng bằng cách gọi tới Factory Method, đồng thời trích xuất phần code tạo của sản phẩm vào Factory Method.\nBạn có thể sẽ cần thêm một tham số tạm thời vào Factory Method để kiểm soát kiểu trả về.\nTại phần này, phần code của Factory Method trông sẽ khá xấu, nó có thể có một toán tử switch lớn để chọn xem loại sản phẩm nào sẽ được tạo. Đừng lo về điều này vì chúng ta sẽ sửa nó sau.\nBây giờ, tạo một tập hợp các lớp con với phần tạo cho từng loại sản phẩm được liệt kê trong Factory Method. Ghi đè phần Factory Method trong các class con và trích dẫn một phần constructor code phù hợp từ phương thức cơ sở.\nNếu có nhiều loại sản phẩm và chúng không phù hợp để tạo các class con cho tất cả chúng, bạn có thể sử dụng lại tham số điều khiển từ lớp cơ sở trong các lớp con.\nVí dụ, tưởng tượng rằng bạn phải tuân theo mô hình các lớp phân cấp như sau: lớp cơ sở Mail với hai lớp con AirMail và GroundMail; các lớp Transport gồm Plane, Truck và Train. Trong khi lớp AirMail chỉ sử dụng đối tượng Plane, GroundMail lại làm việc nhiều với cả hai đối tượng Truck và Train. Bạn có thể tạo một class con mới (gọi là TrainMail) để xử lý cả 2 trường hợp, nhưng đó là sự lựa chọn khác. Phía code khách hàng có thể truyền một đối số vào Factory Method của lớp GroundMail để kiểm soát những loại sản phẩm nào nó muốn nhận.\nSau tất cả các chiết xuất, nếu Factory Method cơ sở trở nên trống, bạn có thể làm cho nó thành trừu tượng và nếu còn lại thứ gì đó trong phương thức này thì bạn có thể biến nó thành hành vi mặc định của phương thức.\nƯu và nhược điểm Ưu điểm:\nBạn tránh được sự liên kết chặt chẽ giữa phần tạo của đối tượng và các sản phẩm cụ thể.\nSingle Responsibility Principle : Bạn có thể chuyển phần code tạo ra sản phẩm vào một nơi nào đó trong trương trình để có thể dễ dàng hỗ trợ.\nOpen/Closed Principle : Bạn có thể đưa ra nhiều kiểu mới của sản phẩm vào chương trình mà không phá vỡ phần code đã tồn tại.\nNhược điểm:\nCode của bạn se trở nên phức tạo hơn khi bạn đưa ra nhiều lớp con để triển khai mẫu này. Trường hợp tốt nhất là khi bạn đang giới thiệu mẫu vào hệ thống phân cấp hiện có của các lớp tạo.\nMối quan hệ với những Khuôn mẫu khác Rất nhiều thiết kế bắt đầu bằng việc sử dụng Factory Method ( ít phức tạo và dễ dàng tùy chỉnh thông qua các lớp con) và phát triển theo hướng Abstract Factory, Prototype hoặc Builder (linh hoạt hơn, nhưng phức tạo hơn).\nCác lớp Abstract Factory thường xuyên dựa trên một tập hợp của các Factory Method, nhưng bạn cũng có thể dử dụng Prototype để soạn thảo các phương thức trên lớp này.\nBạn có thể sử dụng Factory Method cùng với Iterator để thu thập các lớp con và trả về các kiểu khác nhau của vòng lặp, cái mà tương thức với các đối tượng mà chúng ta cần thu gom.\nPrototype không dựa trên kế thừa, vì thế nó không có yếu điểm. Mặt khác, Prototype yêu cầu một khởi tạo phức tạp từ đối tượng nhân bản. Factory Method dựa trên kế thừa nhưng không yêu cầu các bước khởi tạo.\nFactory Method là một Template Method đặc biệt. Đồng thời, Factory Method có thể đóng vai trò là một bước trong Template Method lớn.\n",
    "description": "",
    "tags": null,
    "title": "Factory Method (Phương thức xuất xưởng)",
    "uri": "/design-pattern/structural-design-patterns/factory-method/index.html"
  },
  {
    "content": "Mục tiêu Builder là một creational design pattern cho phép bạn từng bước xây dựng các đối tượng phức tạp. Khuôn mẫu này cho phép bạn tạo ra các loại và biểu diễn khác nhau của một đối tượng bằng cách sử dụng cùng một mã xây dựng.\nĐặt vấn đề Hãy tưởng tượng một đối tượng phức tạp đòi hỏi phải khởi tạo từng bước, tốn nhiều công sức cho nhiều trường và đối tượng lồng nhau. Mã khởi tạo như vậy thường được chôn bên trong một hàm tạo (constructor) khổng lồ với rất nhiều tham số. Hoặc thậm chí tệ hơn: nằm rải rác khắp nơi.\nBạn có thể làm cho chương trình trở nên quá phức tạp bằng cách tạo một lớp con cho mọi cấu hình có thể có của một đối tượng.\nVí dụ: hãy nghĩ về cách tạo một đối tượng House. Để xây dựng một ngôi nhà đơn giản, bạn cần xây dựng bốn bức tường và một sàn nhà, lắp một cánh cửa, lắp một cặp cửa sổ và xây một mái nhà. Nhưng nếu bạn muốn có một ngôi nhà lớn hơn, sáng sủa hơn, có sân sau và các tiện ích khác (như hệ thống sưởi ấm, hệ thống ống nước và dây điện) thì sao?\nGiải pháp đơn giản nhất là mở rộng lớp cơ sở House và tạo một tập hợp các lớp con để bao gồm tất cả các tổ hợp tham số. Nhưng cuối cùng bạn sẽ có một số lượng đáng kể các phân lớp. Bất kỳ tham số mới nào, chẳng hạn như kiểu hiên nhà, sẽ yêu cầu phát triển hệ thống phân cấp này nhiều hơn nữa.\nCó một cách tiếp cận khác không liên quan đến việc tạo các lớp con. Bạn có thể tạo một hàm tạo khổng lồ ngay trong lớp cơ sở House với tất cả các tham số có thể có về đối tượng ngôi nhà. Mặc dù cách tiếp cận này thực sự loại bỏ nhu cầu về các lớp con, nhưng nó lại tạo ra một vấn đề khác.\nHàm tạo có nhiều tham số có nhược điểm của nó: không phải lúc nào cũng cần đến tất cả các tham số.\nTrong đa số các trường hợp, hầu hết các tham số sẽ không được sử dụng, khiến lời gọi hàm tạo trông khá xấu xí . Ví dụ, chỉ một phần nhỏ các ngôi nhà có bể bơi, vì vậy các thông số liên quan đến bể bơi sẽ gần như rất ít khi sử dụng.\nGiải pháp Khuôn mẫu Builder đề xuất bạn trích xuất mã xây dựng đối tượng ra khỏi lớp của nó và chuyển nó sang các đối tượng riêng biệt được gọi là các builder.\nKhuôn mẫu Builder cho phép bạn từng bước xây dựng các đối tượng phức tạp. Builder không cho phép các đối tượng khác truy cập vào sản phẩm trong khi nó đang được xây dựng.\nKhuôn mẫu này tổ chức việc xây dựng đối tượng thành một tập hợp các bước (buildWalls, buildDoor, v.v.). Để tạo một đối tượng, bạn thực hiện một loạt các bước này trên một đối tượng builder. Phần quan trọng là bạn không cần gọi tất cả các bước. Bạn chỉ có thể gọi những bước cần thiết để tạo ra một cấu hình cụ thể của một đối tượng.\nMột số bước xây dựng có thể yêu cầu thực hiện khác nhau khi bạn cần xây dựng các biểu diễn khác nhau của sản phẩm. Ví dụ, các bức tường của cabin có thể được xây dựng bằng gỗ, nhưng các bức tường của lâu đài phải được xây dựng bằng đá.\nTrong trường hợp này, bạn có thể tạo một số lớp builder khác nhau thực hiện cùng một tập hợp các bước xây dựng, nhưng theo một cách khác. Sau đó, bạn có thể sử dụng các builder này trong quy trình xây dựng (tức là, một tập hợp lệnh gọi các bước xây dựng được sắp xếp theo thứ tự) để tạo ra các loại đối tượng khác nhau.\nCác builder khác nhau thực hiện cùng một nhiệm vụ theo nhiều cách khác nhau.\nVí dụ, hãy tưởng tượng một builder xây dựng mọi thứ từ gỗ và thủy tinh, người thứ hai xây dựng mọi thứ bằng đá và sắt và người thứ ba sử dụng vàng và kim cương. Bằng cách gọi cùng một tập hợp các bước, bạn sẽ có được một ngôi nhà thông thường từ builder đầu tiên, một lâu đài nhỏ từ người thứ hai và một cung điện từ người thứ ba. Tuy nhiên, điều này sẽ chỉ hoạt động nếu mã code gọi các bước xây dựng có thể tương tác với các builder bằng interface (giao diện) chung.\nDirector Bạn có thể đi xa hơn và trích xuất một loạt lệnh gọi đến các bước của builder mà bạn sử dụng để xây dựng một prodcut thành một lớp riêng biệt có tên là director. Lớp director xác định thứ tự thực hiện các bước xây dựng, trong khi builder cung cấp việc triển khai cho các bước đó.\nDirector biết cần thực hiện các bước xây dựng nào để có được một sản phẩm hoạt động.\nCó một lớp director trong chương trình của bạn là không cần thiết. Bạn luôn có thể gọi các bước xây dựng theo thứ tự cụ thể trực tiếp từ mã code. Tuy nhiên, lớp director có thể là một nơi tốt để đặt các quy trình xây dựng khác nhau để bạn có thể sử dụng lại chúng trong chương trình của mình.\nNgoài ra, lớp director ẩn hoàn toàn các chi tiết xây dựng sản phẩm khỏi client code. Client chỉ cần liên kết một builder với một director, khởi chạy việc xây dựng với director và nhận kết quả từ builder.\nCấu trúc Director biết cần thực hiện các bước xây dựng nào để có được một sản phẩm hoạt động.\nBuilder interface khai báo các bước xây dựng sản phẩm chung cho mọi loại builder. Concrete Builders cung cấp các triển khai khác nhau của các bước xây dựng. Concrete builders có thể sản xuất các product không tuân theo interface chung. Products là đối tượng kết quả. Các product được tạo bởi các builder khác nhau, không nhất thiết phải thuộc cùng một hệ thống phân cấp hoặc lớp interface. Lớp Director xác định thứ tự gọi các bước xây dựng, vì vậy bạn có thể tạo và sử dụng lại các cấu hình cụ thể của product. Client phải liên kết một trong các đối tượng builder với director. Thông thường, nó chỉ được thực hiện một lần, thông qua các tham số của hàm tạo của director. Sau đó, director sử dụng đối tượng trình builder đó cho tất cả các công việc xây dựng tiếp theo. Tuy nhiên, có một cách tiếp cận khác khi client chuyển đối tượng builder sang phương thức sản xuất của dicrector. Trong trường hợp này, bạn có thể sử dụng một builder khác mỗi khi bạn sản xuất thứ gì đó với director. Mã giả (Pseudocode) Ví dụ về khuôn mẫu Builder này minh họa cách bạn có thể sử dụng lại cùng một mã xây dựng đối tượng khi xây dựng các loại product khác nhau, chẳng hạn như ô tô và tạo hướng dẫn sử dụng tương ứng cho chúng.\nVí dụ về từng bước cấu tạo ô tô và hướng dẫn sử dụng phù hợp với các kiểu ô tô đó.\nMột chiếc ô tô là một đối tượng phức tạp có thể được cấu tạo theo hàng trăm cách khác nhau. Thay vì tạo lớp Car với một hàm tạo khổng lồ, thì chúng tôi đã trích xuất mã lắp ráp ô tô thành một lớp ô tô riêng biệt. Lớp này có một tập hợp các phương thức để cấu hình các bộ phận khác nhau của ô tô.\nNếu client code cần lắp ráp một mô hình ô tô đặc biệt, được tinh chỉnh, mã đó có thể làm việc trực tiếp với builder. Mặt khác, client có thể ủy thác việc lắp ráp cho lớp director, lớp này biết cách sử dụng builder để xây dựng một số mẫu ô tô phổ biến nhất.\nBạn có thể bị sốc, nhưng mọi chiếc xe đều cần có sách hướng dẫn (nghiêm túc mà nói, ai đọc chúng?). Sách hướng dẫn mô tả mọi tính năng của ô tô, vì vậy các chi tiết trong sách hướng dẫn khác nhau tùy theo các mẫu xe khác nhau. Đó là lý do tại sao nên sử dụng lại quy trình xây dựng hiện có cho cả ô tô thực và hướng dẫn sử dụng tương ứng của chúng. Tất nhiên, xây dựng một sổ tay không giống như xây dựng ô tô, và đó là lý do tại sao chúng ta phải cung cấp một lớp builder khác chuyên soạn thảo hướng dẫn này. Lớp này thực hiện các phương pháp xây dựng giống như người anh em chế tạo ô tô của nó, nhưng thay vì chế tạo các bộ phận ô tô, thì nó mô tả chúng. Bằng cách chuyển các builder này đến cùng một đối tượng director, chúng ta có thể tạo ô tô hoặc hướng dẫn sử dụng.\nPhần cuối cùng là tìm nạp đối tượng kết quả. Một chiếc ô tô bằng kim loại và một cuốn sách hướng dẫn bằng giấy, mặc dù có liên quan với nhau, nhưng vẫn là những thứ rất khác nhau. Chúng ta không thể đặt một phương thức để tìm nạp kết quả trong director mà không ghép nối director này với các lớp prodcut cụ thể. Do đó, chúng ta có được kết quả của việc xây dựng từ builder đã thực hiện công việc.\n// Việc sử dụng mẫu Builder chỉ có ý nghĩa khi các product của bạn khá phức tạp và yêu cầu cấu hình mở rộng. Hai sản phẩm sau có liên quan với nhau, mặc dù chúng không có interface chung. class Car is // Một chiếc ô tô có thể có GPS, máy tính hành trình và một số chỗ ngồi. Các kiểu xe ô tô khác nhau (xe thể thao, SUV, cabriolet) có thể được cài đặt hoặc kích hoạt các tính năng khác nhau. class Manual is // Mỗi ô tô nên có một hướng dẫn sử dụng tương ứng với cấu hình của ô tô và mô tả tất cả các tính năng của nó. // builder interface chỉ định các phương thức để tạo các phần khác nhau của các đối tượng product. interface Builder is method reset() method setSeats(...) method setEngine(...) method setTripComputer(...) method setGPS(...) // Các lớp concrete builder tuân theo builder interface và cung cấp các triển khai cụ thể của các bước xây dựng. Chương trình của bạn có thể có một số biến thể của các builder, mỗi biến thể được triển khai khác nhau. class CarBuilder implements Builder is private field car:Car //Phiên bản builder mới phải chứa một đối tượng product trống mà nó sử dụng trong phần lắp ráp tiếp theo. constructor CarBuilder() is this.reset() // Phương thức reset xoá đối tượng đang được xây dựng. method reset() is this.car = new Car() // Tất cả các bước sản xuất đều hoạt động với cùng một phiên bản prodct. method setSeats(...) is // Đặt số ghế trong xe. method setEngine(...) is // Cài đặt một động cơ nhất định. method setTripComputer(...) is // Cài đặt một máy tính hành trình. method setGPS(...) is // Cài đặt hệ thống định vị toàn cầu. // Các concrete builder phải cung cấp các phương thức riêng để truy xuất kết quả. Đó là bởi vì các loại builder khác nhau có thể tạo ra các product hoàn toàn khác nhau và không tuân theo cùng một interface. Do đó, các phương thức như vậy không thể được khai báo trong builder interface (ít nhất là không phải bằng ngôn ngữ lập trình tĩnh). // Thông thường, sau khi trả về kết quả cuối cùng cho client, một phiên bản builder dự kiến sẽ sẵn sàng để bắt đầu sản xuất một product khác. Đó là lý do tại sao thông thường, ta gọi phương thức reset ở cuối thân phương thức `getProduct`. Tuy nhiên, thao tác này không bắt buộc và bạn có thể yêu cầu builder của mình chờ lệnh gọi reset rõ ràng từ client code trước khi loại bỏ kết quả trước đó. method getProduct():Car is product = this.car this.reset() return product // Không giống như các khuôn mẫu khởi tạo khác, builder cho phép chúng ta tạo các product không tuân theo interface chung. class CarManualBuilder implements Builder is private field manual:Manual constructor CarManualBuilder() is this.reset() method reset() is this.manual = new Manual() method setSeats(...) is // Tài liệu về các tính năng của ghế ngồi ô tô.. method setEngine(...) is // Thêm hướng dẫn động cơ. method setTripComputer(...) is // Thêm hướng dẫn máy tính hành trình. method setGPS(...) is // Thêm hướng dẫn GPS. method getProduct():Manual is // Trả về sách hướng dẫn và đặt lại builder. // Director chỉ chịu trách nhiệm thực hiện các bước xây dựng theo một trình tự cụ thể. Nó hữu ích khi sản xuất product theo một đơn đặt hàng hoặc cấu hình cụ thể. Nói một cách chính xác, lớp director là tùy chọn, vì client có thể điều khiển trực tiếp các builder.. class Director is // Director làm việc với bất kỳ phiên bản builder nào mà client code chuyển đến nó. Bằng cách này, client code có thể thay đổi loại cuối cùng của product mới được lắp ráp. Director có thể xây dựng một số biến thể của product bằng cách sử dụng các bước xây dựng giống nhau. method constructSportsCar(builder: Builder) is builder.reset() builder.setSeats(2) builder.setEngine(new SportEngine()) builder.setTripComputer(true) builder.setGPS(true) method constructSUV(builder: Builder) is // ... // The client code tạo một đối tượng builder, chuyển nó cho director và sau đó bắt đầu quá trình xây dựng. Kết quả cuối cùng được lấy từ đối tượng builder. class Application is method makeCar() is director = new Director() CarBuilder builder = new CarBuilder() director.constructSportsCar(builder) Car car = builder.getProduct() CarManualBuilder builder = new CarManualBuilder() director.constructSportsCar(builder) // Product cuối cùng thường được truy xuất từ một đối tượng builder do director không biết và không phụ thuộc vào các concrete builder và product. Manual manual = builder.getProduct() Khả năng áp dụng Sử dụng khuôn mẫu Builder để loại bỏ “telescoping constructor”.\nGiả sử bạn có một hàm tạo với mười tham số tùy chọn. Gọi một con thú như vậy là rất bất tiện; do đó, bạn quá tải (overload) hàm tạo và tạo một số phiên bản ngắn hơn với ít tham số hơn. Các hàm tạo này vẫn tham chiếu đến hàm chính, chuyển một số giá trị mặc định vào bất kỳ tham số nào bị bỏ qua.\nclass Pizza { Pizza(int size) { ... } Pizza(int size, boolean cheese) { ... } Pizza(int size, boolean cheese, boolean pepperoni) { ... } // ... Việc tạo một con quái vật như vậy chỉ có thể thực hiện được trong các ngôn ngữ hỗ trợ nạp chồng phương thức, chẳng hạn như C# hoặc Java.\nKhuôn mẫu Builder cho phép bạn xây dựng các đối tượng từng bước, chỉ sử dụng những bước mà bạn thực sự cần. Sau khi triển khai khuôn mẫu, bạn không cần phải nhồi nhét hàng tá tham số vào hàm tạo của mình nữa.\nSử dụng khuôn mẫu Builder khi bạn muốn mã của mình có thể tạo các biểu diễn khác nhau của một số product (ví dụ: nhà bằng đá và gỗ).\nKhuôn mẫu Builder có thể được áp dụng khi xây dựng các biểu diễn khác nhau của product bao gồm các bước tương tự chỉ khác nhau về chi tiết.\nBuilder interface cơ sở xác định tất cả các bước xây dựng có thể và các concrete builder nào thực hiện các bước này để xây dựng các biểu diễn cụ thể của product. Trong khi đó, director hướng dẫn trình tự xây dựng.\nSử dụng Builder để xây dựng các cây Composite hoặc các đối tượng phức tạp khác.\nKhuôn mẫu Builder cho phép bạn xây dựng product theo từng bước. Bạn có thể hoãn thực hiện một số bước mà không làm hỏng product cuối cùng. Bạn thậm chí có thể gọi các bước một cách đệ quy, điều này rất hữu ích khi bạn cần xây dựng một cây đối tượng.\nMột builder không để lộ poduct chưa hoàn thành trong khi chạy các bước xây dựng. Điều này ngăn client code tìm nạp kết quả không đầy đủ.\nCách triển khai Đảm bảo rằng bạn có thể xác định rõ ràng các bước xây dựng phổ biến để xây dựng tất cả các biểu diễn prodcut có sẵn. Nếu không, bạn sẽ không thể tiếp tục triển khai khuôn mẫu. Khai báo các bước này trong builder interface cơ sở. Tạo một lớp concrete builder cụ thể cho từng biểu diễn product và triển khai các bước xây dựng của chúng. Đừng quên triển khai một phương thức để tìm nạp kết quả của quá trình xây dựng. Lý do tại sao phương pháp này không thể được khai báo bên trong builder interface là vì các builder khác nhau có thể tạo các product không có interface chung. Do đó, bạn không biết kiểu trả về cho một phương thức như vậy là gì. Tuy nhiên, nếu bạn đang xử lý các product từ một hệ thống phân cấp duy nhất, phương pháp tìm nạp có thể được thêm vào interface cơ sở một cách an toàn. Hãy suy nghĩ về việc tạo ra một lớp dicrector. Nó có thể gói gọn nhiều cách khác nhau để xây dựng một product bằng cách sử dụng cùng một đối tượng builder. Client code tạo cả đối tượng builder và director. Trước khi bắt đầu xây dựng, client phải chuyển một đối tượng builder cho director. Thông thường, client chỉ thực hiện việc này một lần, thông qua các tham số của hàm tạo lớp của director. Director sử dụng đối tượng builder này trong tất cả các công việc xây dựng tiếp theo. Có một cách tiếp cận khác, trong đó builder được chuyển cho một phương pháp xây dựng product cụ thể của director. Kết quả xây dựng chỉ có thể được lấy trực tiếp từ director nếu tất cả các product đều tuân theo cùng một interface. Nếu không, client sẽ lấy kết quả từ builder. Ưu và nhược điểm Bạn có thể xây dựng các đối tượng theo từng bước, trì hoãn các bước xây dựng hoặc chạy đệ quy các bước.\nBạn có thể sử dụng lại cùng một mã xây dựng khi xây dựng các biểu diễn khác nhau của prodcut.\nNguyên tắc trách nhiệm duy nhất (Single Responsibility Principle). Bạn có thể tách mã xây dựng phức tạp khỏi logic nghiệp vụ của product.\nĐộ phức tạp tổng thể của mã tăng lên do khuôn mẫu yêu cầu tạo nhiều lớp mới.\nMối quan hệ với các mẫu khác Nhiều thiết kế bắt đầu bằng cách sử dụng Factory Method (ít phức tạp hơn và có thể tùy chỉnh nhiều hơn thông qua các lớp con) và phát triển theo hướng Abstract Factory, Prototype hoặc Builder (linh hoạt hơn nhưng phức tạp hơn). Builder tập trung vào từng bước xây dựng các đối tượng phức tạp. Abstract Factory chuyên tạo các họ đối tượng liên quan. Abstract Factory trả lại product ngay lập tức, trong khi Builder cho phép bạn chạy một số bước xây dựng bổ sung trước khi tìm nạp product. Bạn có thể sử dụng Builder khi tạo các cây Composite phức tạp vì bạn có thể lập trình các bước xây dựng của nó để hoạt động theo cách đệ quy. Bạn có thể kết hợp Builder với Bridge: lớp director đóng vai trò trừu tượng hóa, trong khi các builder khác nhau đóng vai trò triển khai. Abstract Factories, Builders và Prototypes đều có thể được triển khai dưới dạng Singletons. ",
    "description": "",
    "tags": null,
    "title": "Khuôn mẫu Builder",
    "uri": "/design-pattern/creational-design-patterns/builder/index.html"
  },
  {
    "content": "Structural Design Patterns\n",
    "description": "",
    "tags": null,
    "title": "Structural Design Patterns",
    "uri": "/design-pattern/structural-design-patterns/index.html"
  },
  {
    "content": "Sự thật là bạn có thể làm việc với tư cách là một lập trình viên trong nhiều năm mà không biết về một khuôn mẫu nào. Rất nhiều người như thế. Tuy nhiên, ngay cả trong trường hợp đó, bạn có thể đã hoặc đang triển khai một số khuôn mẫu mà không hề hay biết. Vậy thì tại sao chúng ta nên lại dành thời gian tìm hiểu chúng?\nDesign patterns là một bộ công cụ gồm các giải pháp đã được thử và kiểm tra cho các vấn đề phổ biến trong thiết kế phần mềm. Ngay cả khi bạn chưa bao giờ gặp phải những vấn đề này, thì việc biết các mẫu vẫn hữu ích vì nó dạy bạn cách giải quyết tất cả các loại vấn đề bằng cách sử dụng các nguyên tắc của thiết kế hướng đối tượng.\nDesign patterns xác định một ngôn ngữ chung mà bạn và đồng đội của mình có thể sử dụng để giao tiếp hiệu quả hơn. Bạn có thể nói, “Ồ, chỉ cần sử dụng Singleton cho việc đó,” và mọi người sẽ hiểu ý tưởng đằng sau đề xuất của bạn. Không cần giải thích singleton là gì nếu bạn biết khuôn mẫu và tên của nó.\n",
    "description": "",
    "tags": null,
    "title": "Tại sao nên học Design Patterns?",
    "uri": "/design-pattern/introduction/why-should-i-learn-patterns/index.html"
  },
  {
    "content": "Behavioural Design Patterns\n",
    "description": "",
    "tags": null,
    "title": "Behavioural Design Patterns",
    "uri": "/design-pattern/behavioural-design-patterns/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "content": "Blog này nhằm chia sẻ các bài viết về công nghệ hoàn toàn bằng tiếng Việt. Với mong muốn nhiều người Việt Nam nhanh chóng tiếp cận với Công nghệ thông tin mà không gặp phải khó khăn về rào cản ngôn ngữ.\n",
    "description": "",
    "tags": null,
    "title": "NLKH BLOG",
    "uri": "/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tags",
    "uri": "/tags/index.html"
  }
]
